<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Ultimate Tic-Tac-Toe</title>
    <!-- Use Tailwind CSS for a modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Material Symbols for icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=closecontent_copyinfosend" />
    <style>
        /* A little custom CSS for the game board and animations */
        html,
        body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            background-color: #2d3748; /* Darker board background */
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .subgrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            padding: 5px;
            background-color: #4a5568;
            border-radius: 8px;
            position: relative;
            transition: all 0.3s ease-in-out;
        }

            .subgrid.active {
                border: 2px solid #63b3ed; /* Highlight for next move */
                box-shadow: 0 0 10px #63b3ed;
                animation: pulse 1.5s infinite;
            }

        .subcell {
            width: 80px;
            height: 80px;
            background-color: #cbd5e0; /* Light cell background */
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            color: #2d3748;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

            .subcell:hover {
                transform: scale(1.05);
            }

        .subgrid.won .subcell {
            background-color: #2d3748;
            pointer-events: none;
        }

        .winner-mark {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 8rem;
            font-weight: bold;
            color: rgba(226, 232, 240, 0.5); /* Semi-transparent white */
            pointer-events: none;
            z-index: 10;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 5px #63b3ed;
            }

            50% {
                box-shadow: 0 0 20px #63b3ed;
            }

            100% {
                box-shadow: 0 0 5px #63b3ed;
            }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
            color: #e2e8f0;
            width: 80%;
            max-width: 500px;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center p-4">

    <!-- Firebase Imports -->
    <script type="module">
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getDatabase,
            ref,
            onValue,
            set,
            child,
            get,
            push,
            remove,
            update,
            query,
            limitToFirst,
            orderByChild
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        import {
            getAuth,
            signInAnonymously,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // Firebase configuration and initialization
        // Your Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD-wIuod1HspD7ffLzqsJGlsBMoi1iujZ8",
            authDomain: "tic-tac-toe-2-44691.firebaseapp.com",
            projectId: "tic-tac-toe-2-44691",
            storageBucket: "tic-tac-toe-2-44691.firebasestorage.app",
            messagingSenderId: "947987116391",
            appId: "1:947987116391:web:c2c64bc30fd0f810627fc2",
            measurementId: "G-WDR5ZXGXQ7",
            databaseURL: "https://tic-tac-toe-2-44691-default-rtdb.europe-west1.firebasedatabase.app"
        };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const auth = getAuth(app);

        // Global variable to hold the current user's ID
        let currentUserId = null;
        let currentUsername = null;

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                // Generate a random username for the user
                currentUsername = generateRandomUsername();
                console.log("Authenticated with UID:", currentUserId);
                console.log("Generated Username:", currentUsername);
            } else {
                console.log("No user signed in. Signing in anonymously.");
                await signInAnonymously(auth);
            }
        });

        // -------------------------------------------------------------
        // Game Logic Variables and Constants
        // -------------------------------------------------------------
        const X = 0;
        const O = 1;
        const EMPTY = 2;
        const DRAW = 3;

        let bigBoardState = createEmptyBoard(3, EMPTY);
        let subBoardStates = createEmptyBoard(3, createEmptyBoard(3, createEmptyBoard(3, EMPTY)));
        let currentPlayer = X;
        let nextSubgrid = null; // [row, col] of the next valid subgrid to play in
        let players = []; // Stores usernames of Player X and Player O
        let gameRoomName = null;

        // Firebase references
        const gameRoomsRef = ref(database, 'game_rooms');
        const waitingRoomsRef = ref(database, 'waiting_rooms');

        // DOM elements
        const onlineMenuDIV = document.getElementById('onlineMenu');
        const gameDiv = document.getElementById('gameDiv');
        const findRandomGameBtn = document.getElementById('findRandomGameBtn');
        const matchStatusDisplay = document.getElementById('matchStatus');
        const boardContainer = document.getElementById('boardContainer');
        const name1Span = document.getElementById('name1');
        const name2Span = document.getElementById('name2');
        const winmessageDIV = document.getElementById('winmessage');
        const winmessage = document.getElementById('winmessageText');
        const closeWinMessageBtn = document.getElementById('closeWinMessage');

        // -------------------------------------------------------------
        // Game Logic Functions
        // -------------------------------------------------------------

        // Creates an empty board of specified dimensions and fill value
        function createEmptyBoard(rows, fillValue) {
            return Array.from({
                length: rows
            }, () => Array(rows).fill(fillValue));
        }

        // Checks for a win condition on a given board
        function checkWin(board, mark) {
            // Check rows, columns, and diagonals
            for (let i = 0; i < 3; i++) {
                if (board[i][0] === mark && board[i][1] === mark && board[i][2] === mark) return true;
                if (board[0][i] === mark && board[1][i] === mark && board[2][i] === mark) return true;
            }
            if (board[0][0] === mark && board[1][1] === mark && board[2][2] === mark) return true;
            if (board[0][2] === mark && board[1][1] === mark && board[2][0] === mark) return true;
            return false;
        }

        // Checks if a subgrid is full
        function isFullSubgrid(subgrid) {
            return subgrid.every(row => row.every(cell => cell !== EMPTY));
        }

        // Finds the DOM element for a given big board cell
        function findCell(br, bc) {
            return boardContainer.querySelector(`.subgrid[data-br="${br}"][data-bc="${bc}"]`);
        }

        // Renders the board from scratch
        function renderBoard() {
            boardContainer.innerHTML = ''; // Clear previous board
            for (let br = 0; br < 3; br++) {
                for (let bc = 0; bc < 3; bc++) {
                    const subgridDiv = document.createElement('div');
                    subgridDiv.className = 'subgrid';
                    subgridDiv.dataset.br = br;
                    subgridDiv.dataset.bc = bc;

                    if (bigBoardState[br][bc] === EMPTY) {
                        for (let sr = 0; sr < 3; sr++) {
                            for (let sc = 0; sc < 3; sc++) {
                                const subcellDiv = document.createElement('div');
                                subcellDiv.className = 'subcell';
                                subcellDiv.dataset.bigRow = br;
                                subcellDiv.dataset.bigCol = bc;
                                subcellDiv.dataset.subRow = sr;
                                subcellDiv.dataset.subCol = sc;
                                subcellDiv.addEventListener('click', handleMove);
                                subgridDiv.appendChild(subcellDiv);
                            }
                        }
                    } else {
                        // Display winner or draw mark on the subgrid
                        const overlay = document.createElement('div');
                        overlay.className = 'winner-mark';
                        overlay.textContent = bigBoardState[br][bc] === X ? 'X' : bigBoardState[br][bc] === O ? 'O' : '—';
                        subgridDiv.appendChild(overlay);
                    }
                    boardContainer.appendChild(subgridDiv);
                }
            }
        }

        // Updates the display of the board based on the current state
        function updateBoardDisplay() {
            // Iterate through all subcells and update their text content
            for (let br = 0; br < 3; br++) {
                for (let bc = 0; bc < 3; bc++) {
                    const subgrid = boardContainer.querySelector(`.subgrid[data-br="${br}"][data-bc="${bc}"]`);
                    if (subgrid) {
                        if (bigBoardState[br][bc] === EMPTY) {
                            const subcells = subgrid.querySelectorAll('.subcell');
                            subcells.forEach((cell, index) => {
                                const sr = Math.floor(index / 3);
                                const sc = index % 3;
                                const mark = subBoardStates[br][bc][sr][sc];
                                cell.textContent = mark === X ? 'X' : mark === O ? 'O' : '';
                            });
                        }
                    }
                }
            }
        }

        // Highlights the next valid subgrid
        function highlightNextSubgrid() {
            document.querySelectorAll('.subgrid').forEach(subgrid => subgrid.classList.remove('active'));
            if (nextSubgrid) {
                const [br, bc] = nextSubgrid;
                const nextGrid = findCell(br, bc);
                if (nextGrid) {
                    nextGrid.classList.add('active');
                }
            }
        }

        // Updates the player names on the display
        function renderNames() {
            name1Span.textContent = players[0];
            name2Span.textContent = players[1];
            if (currentPlayer === 0) {
                name1Span.classList.add('font-bold', 'text-blue-500');
                name2Span.classList.remove('font-bold', 'text-red-500');
            } else {
                name2Span.classList.add('font-bold', 'text-red-500');
                name1Span.classList.remove('font-bold', 'text-blue-500');
            }
        }

        // Shows a winning animation or message
        function showWinAnimation(winnerName) {
            winmessageDIV.classList.remove('hidden');
            winmessage.textContent = `${winnerName} wins!`;
        }

        // -------------------------------------------------------------
        // Firebase Functions
        // -------------------------------------------------------------

        // Creates a new game room with a name based on the two player's usernames.
        async function createGameRoom(gameRoomName, player1Username, player2Username) {
            const gameRef = child(gameRoomsRef, gameRoomName);

            // Check if the game room already exists
            const snapshot = await get(gameRef);
            if (snapshot.exists()) {
                console.log(`Game room already exists: ${gameRoomName}`);
                return gameRoomName;
            }

            // Save the initial game state
            await set(gameRef, {
                createdAt: Date.now(),
                players: {
                    player1: player1Username,
                    player2: player2Username
                },
                state: {
                    bigBoardState: createEmptyBoard(3, EMPTY),
                    subBoardStates: createEmptyBoard(3, createEmptyBoard(3, createEmptyBoard(3, EMPTY))),
                    currentPlayer: X,
                    nextSubgrid: null
                }
            });

            console.log(`Created new game room: ${gameRoomName}`);
            return gameRoomName;
        }

        // Searches for an opponent or creates a waiting room.
        async function findOrCreateWaitingRoom() {
            try {
                const waitingSnapshot = await get(query(waitingRoomsRef, limitToFirst(1)));
                const waitingRooms = waitingSnapshot.val();

                if (waitingRooms) {
                    const waitingRoomId = Object.keys(waitingRooms)[0];
                    const waitingRoomData = waitingRooms[waitingRoomId];
                    const waitingPlayer = waitingRoomData.player;

                    const playersSorted = [waitingPlayer, currentUsername].sort();
                    const gameRoomName = `game_${playersSorted[0]}_vs_${playersSorted[1]}`;

                    await createGameRoom(gameRoomName, playersSorted[0], playersSorted[1]);

                    await remove(child(waitingRoomsRef, waitingRoomId));
                    return gameRoomName;

                } else {
                    const newWaitingRef = push(waitingRoomsRef);
                    await set(newWaitingRef, { player: currentUsername, createdAt: Date.now() });
                    return null;
                }
            } catch (error) {
                console.error("Error finding or creating waiting room:", error);
                matchStatusDisplay.textContent = "Error finding opponent. Try again.";
                matchStatusDisplay.classList.add('match-error');
                return null;
            }
        }

        // -------------------------------------------------------------
        // Event Listeners and Main Functions
        // -------------------------------------------------------------

        // Function to start the game and set up the listener
        function startGame(roomName) {
            console.log("Starting game in room:", roomName);

            // Assign the room name to the global variable
            gameRoomName = roomName;

            onlineMenuDIV.classList.add('hidden');
            gameDiv.classList.remove('hidden');

            const gameRef = ref(database, 'game_rooms/' + gameRoomName);

            onValue(gameRef, (snapshot) => {
                const gameData = snapshot.val();
                if (gameData) {
                    bigBoardState = gameData.state.bigBoardState;
                    subBoardStates = gameData.state.subBoardStates;
                    currentPlayer = gameData.state.currentPlayer;
                    nextSubgrid = gameData.state.nextSubgrid;

                    players = [gameData.players.player1, gameData.players.player2];

                    // Re-render the board and names to reflect the updated state
                    renderBoard();
                    renderNames();
                    highlightNextSubgrid();
                    updateBoardDisplay();
                } else {
                    // Game room was deleted, handle ending the game
                    console.log("Game ended. Returning to main menu.");
                    onlineMenuDIV.classList.remove('hidden');
                    gameDiv.classList.add('hidden');
                }
            });
        }

        // Function to handle a player's move, with turn-based check and database update.
        async function handleMove(e) {
            // Check if it's the current player's turn based on their username.
            if (currentUsername !== players[currentPlayer]) {
                console.log("It's not your turn!");
                return; // Exit the function, preventing the move
            }

            const el = e.currentTarget;
            const br = +el.dataset.bigRow,
                bc = +el.dataset.bigCol;
            const sr = +el.dataset.subRow,
                sc = +el.dataset.subCol;

            if (bigBoardState[br][bc] !== EMPTY) return;
            if (subBoardStates[br][bc][sr][sc] !== EMPTY) return;
            if (nextSubgrid && (nextSubgrid[0] !== br || nextSubgrid[1] !== bc)) return;

            const mark = currentPlayer === 0 ? X : O;

            // Update local state first
            subBoardStates[br][bc][sr][sc] = mark;

            // Check if subgrid is won
            if (checkWin(subBoardStates[br][bc], mark)) {
                bigBoardState[br][bc] = mark;
            } else if (isFullSubgrid(subBoardStates[br][bc])) {
                bigBoardState[br][bc] = DRAW;
            }

            // Check if big grid is won
            if (checkWin(bigBoardState, mark)) {
                // Handle win condition
                winmessageDIV.style.display = 'block';
                showWinAnimation(players[currentPlayer]);
                winmessage.innerHTML = `${players[currentPlayer]} won!`;
                gameDiv.querySelectorAll('.subcell').forEach(sc => sc.style.pointerEvents = 'none');
            }

            // Determine next subgrid
            if (bigBoardState[sr][sc] === EMPTY) {
                nextSubgrid = [sr, sc];
            } else {
                nextSubgrid = null;
            }

            currentPlayer = 1 - currentPlayer;

            // Prepare the updated state object for Firebase
            const updatedState = {
                bigBoardState: bigBoardState,
                subBoardStates: subBoardStates,
                currentPlayer: currentPlayer,
                nextSubgrid: nextSubgrid
            };

            // Update the Firebase Realtime Database
            await update(ref(database, 'game_rooms/' + gameRoomName + '/state'), updatedState);
        }

        findRandomGameBtn.addEventListener('click', async () => {
            if (!currentUsername) {
                matchStatusDisplay.textContent = "Please wait for your username to load.";
                matchStatusDisplay.classList.remove('hidden');
                return;
            }
            matchStatusDisplay.textContent = "Searching for opponent...";
            matchStatusDisplay.classList.remove('hidden');
            matchStatusDisplay.classList.remove('match-found');
            matchStatusDisplay.classList.remove('match-error');
            matchStatusDisplay.classList.add('match-loading');
            findRandomGameBtn.disabled = true;

            const roomName = await findOrCreateWaitingRoom();

            if (roomName) {
                matchStatusDisplay.textContent = "Opponent found! Starting game...";
                matchStatusDisplay.classList.remove('match-loading');
                matchStatusDisplay.classList.add('match-found');
                setTimeout(() => startGame(roomName), 1000);
            } else {
                matchStatusDisplay.textContent = "Waiting for an opponent...";
                matchStatusDisplay.classList.remove('hidden');
                matchStatusDisplay.classList.remove('match-error');
                matchStatusDisplay.classList.remove('match-found');
                matchStatusDisplay.classList.add('match-loading');
            }

            // Re-enable the button after a delay
            setTimeout(() => {
                findRandomGameBtn.disabled = false;
            }, 2000);
        });

        // Simple random username generator
        function generateRandomUsername() {
            const adjectives = ['swift', 'clever', 'brave', 'silly', 'happy', 'bright'];
            const animals = ['tiger', 'panda', 'cat', 'dog', 'pigeon', 'shark'];
            const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const animal = animals[Math.floor(Math.random() * animals.length)];
            return `${adjective} ${animal}`;
        }
    </script>

    <!-- Main Game Interface -->
    <div id="mainContainer" class="flex flex-col items-center justify-center p-4">

        <!-- Online Menu Section -->
        <div id="onlineMenu" class="bg-gray-800 p-8 rounded-xl shadow-lg text-center">
            <h1 class="text-4xl font-bold mb-6 text-indigo-400">Ultimate Tic-Tac-Toe</h1>
            <p class="text-lg mb-8">Find a random opponent to play against online!</p>
            <button id="findRandomGameBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105">
                Find Random Opponent
            </button>
            <p id="matchStatus" class="mt-4 text-sm hidden"></p>
        </div>

        <!-- Game Board Section -->
        <div id="gameDiv" class="hidden flex flex-col items-center">
            <div class="flex items-center justify-between w-full max-w-lg mb-6 text-2xl font-semibold">
                <span id="name1" class="text-blue-400">Player 1</span>
                <span class="text-gray-500 mx-4">vs</span>
                <span id="name2" class="text-red-400">Player 2</span>
            </div>
            <div id="boardContainer" class="board">
                <!-- Board will be rendered here by JavaScript -->
            </div>
        </div>

    </div>

    <!-- Win Message Modal -->
    <div id="winmessage" class="modal">
        <div class="modal-content">
            <h2 class="text-3xl font-bold mb-4">Game Over!</h2>
            <p id="winmessageText" class="text-xl mb-6"></p>
            <button id="closeWinMessage" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">
                Close
            </button>
        </div>
    </div>

    <script>
        closeWinMessageBtn.addEventListener('click', () => {
            winmessageDIV.style.display = 'none';
        });
    </script>
</body>

</html>
