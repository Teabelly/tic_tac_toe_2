<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <title>Random Username Generator</title>
    
    
 
 	 <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=closecontent_copyinfosend" />
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
    
        /* Your existing CSS here, adapted for the username generator context */
        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: auto;
        }

        body {
            font-family: "Inter", sans-serif; /* Prefer Inter as per instructions */
            /* background-image: url('background_v001p0.png');
    			background-size: cover; */

            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #f7f3f2ff; /* Light background */
            color: #333;
            padding: 0.1rem;
            box-sizing: border-box;
        }

        .container {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); /* Added subtle shadow */
            text-align: center;
            max-width: 95%;
            width: 400px;
            margin-bottom: 2%;
        }

        /* New styles for the username row */
        .username-info-row {
            display: flex;
            align-items: center; /* Vertically align items in the middle */
            justify-content: center; /* Center content horizontally */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 0.5rem; /* Space between items */
            margin-bottom: 1.5rem; /* Keep some space below this row */
        }

        .username-info-row h1 {
            font-size: 1rem; /* Adjust font size to fit in a row */
            margin-bottom: 0; /* Remove default h1 margin */
            white-space: nowrap; /* Prevent "Username:" from wrapping */
            color: #1a202c; /* Ensure color is consistent */
        }

        #usernameDisplay {
            font-size: 1rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0; /* Remove default margin for inline element */
            flex-grow: 1; /* Allow it to take available space */
            text-align: left; /* Align text to left within its flex item */
            min-height: 0.5rem; /* Ensure space even when loading */
            display: flex; /* Use flex to center content vertically within its own space */
            align-items: center;
            justify-content: flex-start; /* Align text to start */
            word-break: break-all; /* Prevent overflow for long names */
        }
        
        #usernameInfoDisplay {
            font-size: 1rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0; /* Remove default margin for inline element */
            flex-grow: 1; /* Allow it to take available space */
            text-align: left; /* Align text to left within its flex item */
            min-height: 0.5rem; /* Ensure space even when loading */
            display: flex; /* Use flex to center content vertically within its own space */
            align-items: center;
            justify-content: flex-start; /* Align text to start */
            word-break: break-all; /* Prevent overflow for long names */
        }

        .loading-text {
            color: #6b7280;
            font-style: italic;
        }



        /* New styles for copy button */
        .copy-button {
            background-color: #69baceff; /* A lighter blue */
            color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer; /* Indicate it's clickable */
            border: none;
            outline: none;
            
            display: flex; /* To center the icon */
            align-items: center;
            justify-content: center;
        }
        .copy-button:hover {
            background-color: #60a5fa;
            transform: translateY(-1px);
        }
        .copy-button:active {
            background-color: #69baceff;
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba[0, 0, 0, 0.1];
        }
        .copy-button .material-symbols-outlined {
            font-size: 1.2rem; /* Adjust icon size */
            line-height: 1; /* Ensure icon is centered */
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; /* Ensure icon style */
        }
         
        .info-username {
            background-color: #60a5fa; /* A lighter blue */
            color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            
            border: none;
            outline: none;
            
            display: flex; /* To center the icon */
            align-items: center;
            justify-content: center;
        }

        .error-message {
            color: #e53e3e; /* Red for errors */
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .success-message {
            color: #38a169; /* Green for success */
            margin-top: 1rem;
            font-size: 0.9rem;
        }


        /* Dark Mode styles (from original script, adapted) */
        body.dark-mode {
            background-color: #111;
            color: #999;
        }
        body.dark-mode .container {
            background-color: #222;
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.05);
        }
        body.dark-mode h1 {
            color: #eee;
        }
        body.dark-mode #usernameDisplay, body.dark-mode #onlineUsersCount, body.dark-mode .invite-item, body.dark-mode #matchStatus {
            color: #ccc;
        }
        body.dark-mode .generate-button {
            background-color: #3182ce;
        }
        body.dark-mode .generate-button:hover {
            background-color: #2b6cb0;
        }
        body.dark-mode .generate-button:active {
            background-color: #1a569d;
        }
        body.dark-mode .copy-button {
            background-color: #3b82f6;
        }
        body.dark-mode .copy-button:hover {
            background-color: #2563eb;
        }
        body.dark-mode .copy-button:active {
            background-color: #1a569d;
        }
        body.dark-mode .loading-text {
            color: #888;
        }
        body.dark-mode .error-message {
            color: #f56565;
        }
        body.dark-mode .success-message {
            color: #68d391;
        }

        /* Dark mode toggle switch styles (from original script) */
        .switch {
            position: absolute; /* Changed to absolute to position independently */
            top: 1rem; /* Adjust as needed */
            right: 1rem; /* Adjust as needed */
            display: inline-block;
            width: 50px;
            height: 24px;
            z-index: 10; /* Ensure it's above other content */
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "☀";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            color: black;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
            content: "☾";
            color: black;
        }
         
        /* Material Symbols Icon settings */
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24
        }
         
        /* Styles for online users count */
        #onlineUsersCount {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4a5568;
            margin-top: 0.5rem; /* Adjust spacing as needed */
        }

        /* Styles for invite section */
        #inviteInput {
            border: 1px solid #cbd5e0; /* Light gray border */
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: calc(100% - 70px); /* Adjust width to fit button */
            margin-right: 0.5rem;
            box-sizing: border-box; /* Include padding in width */
            font-size: 1rem;
            color: #333;
        }
        body.dark-mode #inviteInput {
            background-color: #444;
            border-color: #555;
            color: #eee;
        }

        #sendInviteBtn {
            background-color: #3db15eff; /* Green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #sendInviteBtn:hover {
            background-color: #45a049;
        }
        body.dark-mode #sendInviteBtn {
            background-color: #48bb78;
        }
        body.dark-mode #sendInviteBtn:hover {
            background-color: #38a169;
        }

        /* Styles for invite lists */
        .invite-list {
            list-style: none;
            padding: 0;
            margin-top: 1rem;
            text-align: left;
        }

        .invite-item {
            background-color: #f0f4f8; /* Light background for items */
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            font-size: 1rem;
            color: #333;
            word-break: break-word; /* Ensure long usernames wrap */
        }
        body.dark-mode .invite-item {
            background-color: #333;
            color: #ccc;
            box-shadow: 0 1px 3px rgba(255, 255, 255, 0.05);
        }

        .invite-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.3rem;
            margin-left: 0.5rem;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }
        .invite-actions button:hover {
            transform: scale(1.1);
        }
        .invite-actions .accept-btn {
            color: #4CAF50; /* Green tick */
        }
        .invite-actions .reject-btn {
            color: #e53e3e; /* Red cross */
        }
        .invite-actions .cancel-btn { /* NEW STYLE for cancel button */
            color: #ff9800; /* Orange for cancel */
        }
        
        .invite-status-pending {
            color: #6b7280; /* Gray for pending */
            font-style: italic;
            font-size: 0.9em;
        }

        /* Styles for random match section */
        #randomMatchSection {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e2e8f0; /* Separator line */
        }
        body.dark-mode #randomMatchSection {
            border-color: #4a5568;
        }

        #findRandomGameBtn {
            background-color: #b46463ff; /* Purple */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        #findRandomGameBtn:hover {
            background-color: #b46462ff;
            transform: translateY(-1px);
        }
        #findRandomGameBtn:active {
            background-color: #7D3C98;
            transform: translateY(0);
        }
        #matchStatus {
            margin-top: 1rem;
            font-size: 1.1rem;
            font-weight: 500;
        }
        .match-loading {
            color: #60a5fa; /* Blue for loading */
            font-style: italic;
        }
        .match-found {
            color: #38a169; /* Green for found */
            font-weight: bold;
        }
        .match-error {
            color: #e53e3e; /* Red for error */
        }
        
        
        .usernameInfoDisplay {
			    position: relative;
			    display: inline-block;
			    cursor: pointer;
			}
			
			.hover-message {
			    visibility: hidden;
			    opacity: 0;
			    width: 200px; /* Adjust as needed */
			    background-color: #555;
			    color: #fff;
			    text-align: center;
			    border-radius: 6px;
			    padding: 10px 10px;
			    position: absolute;
			    z-index: 1;
			    bottom: 125%; /* Still positions it above the icon */
			    /* *** MODIFIED PROPERTIES FOR LEFT ALIGNMENT *** */
			    left: 0; /* Align to the left edge of the parent */
			    margin-left: 0; /* Remove the negative margin */
			    /* ********************************************* */
			    transition: opacity 0.3s, visibility 0.3s;
			}
			
			.hover-message::after {
			    content: "";
			    position: absolute;
			    top: 100%; /* At the bottom of the tooltip */
			    /* *** MODIFIED PROPERTIES FOR LEFT-ALIGNED ARROW *** */
			    left: 10px; /* Adjust this value to position the arrow under the icon */
			    margin-left: 0; /* Remove the negative margin */
			    /* ************************************************* */
			    border-width: 5px;
			    border-style: solid;
			    border-color: #555 transparent transparent transparent; /* Arrow pointing upwards */
			}
			
			.usernameInfoDisplay:hover .hover-message {
			    visibility: visible;
			    opacity: 1;
			}
			
			/* Optional: Style for the info icon itself */
			.usernameInfoDisplay .material-symbols-outlined {
			    font-size: 24px;
			    color: #333;
			}

        .main-title {
            width: 90vw; /* 70% of the viewport width */
            text-align: center; /* Center the text inside the div */

            box-sizing: border-box; /* Include padding in the width calculation */

            align-items: center; /* This centers the items vertically */
            justify-content: center;
            margin-top: 15%;
            display: flex;
            /* Change the direction of the flex container to vertical */
            flex-direction: column;
        }
			
			.main-title h1 {
			    margin: 0; /* Remove default h1 margin */
			    font-size: 1em; /* Adjust font size as needed */
			    color: #333; /* Dark text color */
			}

        .hidden {
            display: none;
        }

        .highlight {
            color: #9bbd9b;
            font-weight: bold;
        }

        body.dark-mode .highlight {
            color: #eee;
        }


        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            width: 90vmin;
            margin: auto;
        }

        .cell {
            position: relative;
            background: #eee;
            border: 2px solid #000;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            aspect-ratio: 1;
        }

            .cell .winner-mark {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10vmin;
                color: rgba(0,0,0,0.2);
                pointer-events: none;
                font-size: 30vmin;
            }


        .subcell {
            border: 1px solid #999;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 4vmin;
            width: 100%;
            height: 100%;
        }

        .active-subgrid {
            background: #cfc;
        }

        body.dark-mode .active-subgrid {
            box-shadow: 0 0 10px #999 inset;
        }



        .won {
            background: #ccc;
            pointer-events: none;
        }

        body.dark-mode {
            background-color: #111;
            color: #999;
        }

        body.dark-mode .cell {
            background-color: #222;
            border-color: #666;
        }

        body.dark-mode .subcell {
            border-color: #444;
        }

        body.dark-mode .highlight {
            color: #eee;
        }

        body.dark-mode .winner-mark {
            color: rgba(255, 255, 255, 0.2);
        }

        .winOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .header-image {
            /* This is the class for your image */
            width: 75%; /* The image will take up 100% of its parent's width */
            margin-top: 1%;
        }

        .body-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* This will push content to the top */
            width: 100vw;
            height: 100vh;
        }

    </style>
    
</head>

<body>

    

    <div id="onlineMenu" class="body-wrapper">



        <label class="switch" id="darkModeSwitch">
            <input type="checkbox" id="darkModeToggle">
            <span class="slider"></span>
        </label>



        <div class="main-title">
            <img id="logoImage" class="header-image" src="images/logo_online.png" alt="wombatLogoOnline">
            <h1> Play online v0.04 </h1>
        </div>



        <div class="container">


            <div class="username-info-row">

                <div id="info-username" class="usernameInfoDisplay">
                    <span class="material-symbols-outlined"> info </span>
                    <div class="hover-message">
                        For privacy and security of users your username is randomly generated.
                    </div>
                </div>
                <h1>Username: </h1>

                <button id="copyBtn" class="copy-button">
                    <span class="material-symbols-outlined">content_copy</span>
                </button>

                <span id="usernameDisplay" class="loading-text">Loading...</span>



            </div>
            <p id="errorMessage" class="error-message hidden"></p>
            <p id="inviteMessage" class="hidden"></p>
        </div>

        <div class="container" style="display:none;">
            <h1>Send Invite: </h1>
            <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                <input type="text" id="inviteInput" placeholder="username..."></input>
                <button id="sendInviteBtn"><span class="material-symbols-outlined">send</span></button>
            </div>
            <p id="sendInviteMessage" class="hidden"></p> <ul id="sentInvitesList" class="invite-list">
                <li class="loading-text">No sent invites.</li>
            </ul>
        </div>

        <div class="container" style="display:none;">
            <h1>Challenge(s): </h1>
            <ul id="receivedInvitesList" class="invite-list">
                <li class="loading-text">No pending challenges.</li>
            </ul>
        </div>

        <div class="container" id="randomMatchSection">
            <h1>Find Random Game:</h1>
            <button id="findRandomGameBtn">Find Opponent</button>
            <p id="matchStatus" class="hidden"></p>
        </div>

        <div class="container">
            <h1>Users Online:</h1>
            <span id="onlineUsersCount" class="loading-text">Counting...</span>
        </div>

    </div>

    <div id="game" class="hidden">

        <div class="players">
            <span id="name1"></span> &nbsp;  (X)  &nbsp; &nbsp;  <i>vs</i> &nbsp;  &nbsp;  <span id="name2"></span>  &nbsp; (O)
        </div>



        <div class="board" id="bigBoard"></div>

        <div id="winOverlay"></div>

        <div id="winMessage" style="display:none;">

            <h1 id="winMessageh1"> </h1>

            <button id="resetBtn" class="button">
                <span class="material-symbols-outlined">refresh</span> Rematch
            </button>

        </div>

    </div>






    <script type="module">



        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
        import { getDatabase, ref, get, set, onValue, push, update, remove, onDisconnect, query, limitToFirst, orderByChild, runTransaction, child } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-database.js";

        // Your Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD-wIuod1HspD7ffLzqsJGlsBMoi1iujZ8",
            authDomain: "tic-tac-toe-2-44691.firebaseapp.com",
            projectId: "tic-tac-toe-2-44691",
            storageBucket: "tic-tac-toe-2-44691.firebasestorage.app",
            messagingSenderId: "947987116391",
            appId: "1:947987116391:web:c2c64bc30fd0f810627fc2",
            measurementId: "G-WDR5ZXGXQ7",
            databaseURL: "https://tic-tac-toe-2-44691-default-rtdb.europe-west1.firebasedatabase.app"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Firebase References
        const usernameComponentsRef = ref(database, 'username_components');
        const onlineUsersRef = ref(database, 'online_users');
        const invitesRef = ref(database, 'invites');
        const waitingRoomsRef = ref(database, 'waiting_rooms'); // NEW Firebase Ref

        const gameRoomsRef = ref(database, 'game_rooms');


        // DOM Elements
        const usernameDisplay = document.getElementById('usernameDisplay');
        const generateBtn = document.getElementById('generateBtn');
        const errorMessage = document.getElementById('errorMessage');
        const inviteMessage = document.getElementById('inviteMessage');
        const sendInviteMessage = document.getElementById('sendInviteMessage');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const onlineUsersCountDisplay = document.getElementById('onlineUsersCount');
        const copyBtn = document.getElementById('copyBtn');

        const inviteInput = document.getElementById('inviteInput');
        const sendInviteBtn = document.getElementById('sendInviteBtn');
        const sentInvitesList = document.getElementById('sentInvitesList');
        const receivedInvitesList = document.getElementById('receivedInvitesList');

        // NEW DOM elements for matchmaking
        const findRandomGameBtn = document.getElementById('findRandomGameBtn');
        const matchStatusDisplay = document.getElementById('matchStatus');

        let currentUsername = null;
        const localStorageKey = 'userGeneratedUsername';

        const inviteOnDisconnectRefs = {};
        let currentRoomRef = null; // NEW: To keep track of the room the current user is in
        let playerNumber = null; // NEW: To store if the user is player1 or player2
        let gameRoomName = null;







        // maatch found elements


        const height = window.innerHeight;
        document.documentElement.style.setProperty('--vh', `${height * 0.01}px`);

        const onlineMenuDIV = document.getElementById('onlineMenu');
        const gameDiv = document.getElementById('game');
        const name1Span = document.getElementById('name1');
        const name2Span = document.getElementById('name2');
        const bigBoardDiv = document.getElementById('bigBoard');
        const winmessage = document.getElementById('winMessageh1');
        const winmessageDIV = document.getElementById('winMessage');

        let players = [];
        let currentPlayer = 0; // 0 or 1
        let nextSubgrid = null; // [row, col] or null if any
        let bigBoardState = Array(3).fill(0).map(() => Array(3).fill(0)); // 0 / 'X' / 'O'
        let subBoardStates = Array(3).fill(0).map(() => Array(3).fill(0).map(() =>
            Array(3).fill(0).map(() => Array(3).fill(0))
        ));



        const initialState = {
            bigBoardState: bigBoardState,
            subBoardStates: subBoardStates,
            currentPlayer: 0,
            nextSubgrid: null,
            players: {
                player1: currentUsername,
                player2: null
            }
        };

        const EMPTY = 0;
        const X = 1;
        const O = 2;
        const DRAW = 3;
        let currentRoomName = null;






        // --- Helper Functions for UI Messages ---
        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
            element.classList.remove('error-message', 'success-message', 'match-loading', 'match-found', 'match-error');
        }

        function showMessage(element, message, type = 'error') {
            element.textContent = message;
            element.classList.remove('hidden');
            element.classList.add(
                type === 'success' ? 'success-message' :
                    type === 'loading' ? 'match-loading' :
                        type === 'found' ? 'match-found' :
                            'error-message'
            );
            // Hide after a few seconds, unless it's a 'loading' or 'found' message
            if (type !== 'loading' && type !== 'found') {
                setTimeout(() => hideMessage(element), 5000);
            }
        }

        function hideGeneralError() { hideMessage(errorMessage); }
        function showGeneralError(message) { showMessage(errorMessage, message, 'error'); }

        function hideInviteMessage() { hideMessage(inviteMessage); }
        function showInviteMessage(message, type = 'error') { showMessage(inviteMessage, message, type); }

        function hideSendInviteMessage() { hideMessage(sendInviteMessage); }
        function showSendInviteMessage(message, type = 'error') { showMessage(sendInviteMessage, message, type); }

        function hideMatchStatus() { hideMessage(matchStatusDisplay); }
        function showMatchStatus(message, type = 'error') { showMessage(matchStatusDisplay, message, type); }



        async function setOnlineStatus(username, oldUsername = null) {
            if (!username) return;

            // Remove old username's online status if it exists and is different
            if (oldUsername && oldUsername !== username) {
                const oldUserRef = ref(database, `online_users/${oldUsername.replace(/\s/g, '_')}`);
                await set(oldUserRef, null).catch(error => console.error("Error removing old username's online status:", error));
                //console.log(`User ${oldUsername} is now offline.`);
            }

            const userRef = ref(database, `online_users/${username.replace(/\s/g, '_')}`);
            try {
                await set(userRef, true);
                // Set up onDisconnect to remove this user from online_users
                onDisconnect(userRef).remove();
                //console.log(`User ${username} is now online.`);
            } catch (error) {
                console.error("Error setting online status:", error);
                showGeneralError(`Failed to set online status: ${error.message}`);
            }
        }


        async function generateOrLoadUsername(forceNew = false) {
            usernameDisplay.textContent = 'Loading username...';
            usernameDisplay.classList.add('loading-text');
            hideGeneralError();
            hideInviteMessage();
            hideSendInviteMessage();
            hideMatchStatus(); // Clear match status on username change

            let usernameFromLocalStorage = localStorage.getItem(localStorageKey);
            let newUsername = null;

            // Handle existing username cleanup for the *old* currentUsername, if any
            if (currentUsername) {
                // Cancel all onDisconnect operations for invites previously sent by this user
                for (const inviteId in inviteOnDisconnectRefs) {
                    if (inviteOnDisconnectRefs.hasOwnProperty(inviteId)) {
                        await inviteOnDisconnectRefs[inviteId].cancel()
                            .catch(err => console.error(`Error canceling onDisconnect for invite ${inviteId}:`, err));
                    }
                }
                inviteOnDisconnectRefs = {}; // Clear the map

                // Stop listening for all invites (the onValue listener)
                // You'll need to store and manage the off() function if you want to stop listeners.
                // For now, onValue listeners will be re-applied with the new username.
                // You might need to add `off(ref(database, 'invites'))` here to be more explicit.
                // off(invitesRef);
                // Clear existing invites from UI for old user
                sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
                receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';

                // --- NEW: Handle cleanup for matchmaking if the user was in a room ---
                if (currentRoomRef) {
                    //console.log("Leaving previous room on username change.");
                    // We use remove() on the entire room to reset it completely if the user leaves
                    // If the other player is still in the room, this will trigger the room reset logic.
                    await remove(currentRoomRef).catch(err => console.error("Error leaving previous room:", err));
                    currentRoomRef = null;
                    playerNumber = null;
                }
            }


            if (!forceNew && usernameFromLocalStorage) {
                newUsername = usernameFromLocalStorage;
                usernameDisplay.textContent = newUsername;
                usernameDisplay.classList.remove('loading-text');
                console.log("Loaded username from localStorage:", newUsername);
            } else {
                try {
                    const snapshot = await get(usernameComponentsRef);

                    if (snapshot.exists()) {
                        const components = snapshot.val();

                        const emotions = components.emotions ? Object.keys(components.emotions) : [];
                        const colors = components.colours ? Object.keys(components.colours) : [];
                        const animals = components.animal ? Object.keys(components.animal) : [];

                        if (emotions.length > 0 && colors.length > 0 && animals.length > 0) {
                            const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                            const randomColor = colors[Math.floor(Math.random() * colors.length)];
                            const randomAnimal = animals[Math.floor(Math.random() * animals.length)];

                            newUsername = `${randomEmotion} ${randomColor} ${randomAnimal}`;
                            usernameDisplay.textContent = newUsername;
                            usernameDisplay.classList.remove('loading-text');
                            localStorage.setItem(localStorageKey, newUsername); // Save to localStorage
                            console.log("Generated and saved new username:", newUsername);

                        } else {
                            showGeneralError("Username components are incomplete or empty in Firebase. Please check your database structure.");
                            newUsername = "FallbackUser";
                            usernameDisplay.textContent = newUsername;
                            usernameDisplay.classList.remove('loading-text');
                            localStorage.setItem(localStorageKey, newUsername); // Save fallback
                        }
                    } else {
                        showGeneralError("No username components found in Firebase. Please ensure 'username_components' exists and contains data.");
                        newUsername = "NoDataUser";
                        usernameDisplay.textContent = newUsername;
                        usernameDisplay.classList.remove('loading-text');
                        localStorage.setItem(localStorageKey, newUsername); // Save fallback
                    }
                } catch (error) {
                    console.error("Error fetching username components from Firebase:", error);
                    showGeneralError(`Failed to fetch username components: ${error.message}`);
                    newUsername = "ErrorUser";
                    usernameDisplay.textContent = newUsername;
                    usernameDisplay.classList.remove('loading-text');
                    localStorage.setItem(localStorageKey, newUsername); // Save error fallback
                }
            }

            // Set online status and start listeners for the new or loaded username
            if (newUsername) {
                // Pass oldUsername to setOnlineStatus for explicit removal
                setOnlineStatus(newUsername, currentUsername);
                currentUsername = newUsername; // Update global currentUsername
                listenForInvites(currentUsername);
            }
        }








        async function findAndJoinRoom() {

            if (!currentUsername) {
                showMatchStatus('Please generate a username first.', 'error');
                return;
            }

            findRandomGameBtn.disabled = true;
            showMatchStatus('Searching for a match...', 'loading');

            if (!waitingRoomsRef) {
                console.error("Waiting rooms reference is not initialized.");
                showMatchStatus('Matchmaking service is not available. Please try again.', 'error');
                findRandomGameBtn.disabled = false;
                return;
            }

            let roomFound = false;

            for (let i = 1; i <= 10; i++) {
                const roomRef = child(waitingRoomsRef, `room${i}`);
                try {
                    const { committed, snapshot } = await runTransaction(roomRef, (currentData) => {
                        if (currentData === null) {
                            return { player1: currentUsername };
                        }
                        if (!currentData.player1) {
                            currentData.player1 = currentUsername;
                            return currentData;
                        }
                        if (!currentData.player2) {
                            currentData.player2 = currentUsername;
                            return currentData;
                        }
                        return undefined;
                    });

                    if (committed) {
                        roomFound = true;
                        const roomData = snapshot.val();
                        currentRoomRef = roomRef;

                        if (roomData.player1 === currentUsername) {
                            playerNumber = 1;
                        } else if (roomData.player2 === currentUsername) {
                            playerNumber = 2;
                        }

                        onDisconnect(child(roomRef, `player${playerNumber}`)).remove();

                        // Listen for changes in this specific room
                        onValue(roomRef, (roomSnapshot) => {
                            const roomState = roomSnapshot.val();

                            if (!roomState) {
                                showMatchStatus('Opponent disconnected. Room reset. Please find a new match.', 'error');
                                findRandomGameBtn.disabled = false;
                                currentRoomRef = null;
                                playerNumber = null;
                                return;
                            }

                            // Check if both players are in the room
                            if (roomState && roomState.player1 && roomState.player2) {

                                showMatchStatus('Match was made! The game can now begin.', 'found');



                                findRandomGameBtn.disabled = true;

                                // Sort players to get a consistent game room name
                                const playersSorted = [roomState.player1, roomState.player2].sort();
                                const gameRoomName = `${playersSorted[0]}_vs_${playersSorted[1]}`;

                                // Get the game room reference
                                const gameRef = child(gameRoomsRef, gameRoomName);

                                // Inside your joinGame or createGame function
                                localStorage.setItem('ttt2_currentGameRoom', gameRoomName);
                                //localStorage.setItem('ultimateTTTPlayerId', userId);

                                // This check ensures only one player creates the room, but both players get the game room name
                                get(gameRef).then(async (gameSnapshot) => {
                                    if (!gameSnapshot.exists()) {
                                        const initialState = {
                                            bigBoardState: Array(3).fill(0).map(() => Array(3).fill(0)),
                                            subBoardStates: Array(3).fill(0).map(() => Array(3).fill(0).map(() => Array(3).fill(0).map(() => Array(3).fill(0)))),
                                            currentPlayer: Math.floor(Math.random() * 2),
                                            nextSubgrid: null
                                        };
                                        await createGameRoom(initialState, roomState.player1, roomState.player2);
                                    }

                                    // This is the crucial part: call the listener for BOTH players
                                    // after the game room has been established.
                                    onlineMenuDIV.classList.add("hidden");
                                    gameDiv.classList.remove("hidden");
                                    players = [roomState.player1, roomState.player2];
                                    createBoard();
                                    listenForGameUpdates(gameRoomName);
                                });
                            } else {
                                showMatchStatus('Waiting for an opponent...', 'loading');
                                findRandomGameBtn.disabled = true;
                            }
                        });
                        break;
                    }
                } catch (error) {
                    console.error(`Error joining room ${i}:`, error);
                }
            }
            if (!roomFound) {
                showMatchStatus('All rooms are full. Please try again in a moment.', 'error');
                findRandomGameBtn.disabled = false;
            }
        }

        function checkReconnection() {

            const savedGameId = localStorage.getItem('ttt2_currentGameRoom');

            if (savedGameId) {

                // Try to reconnect to this game
                gameRoomName = savedGameId;
                onlineMenuDIV.classList.add("hidden");
                gameDiv.classList.remove("hidden");
                
                createBoard();
                listenForGameUpdates(gameRoomName);
                //reconnectToGame(savedGameId, savedPlayerId);
            }
        }
        
        //checkReconnection();



        /**
         * Listens for changes in the online_users node and updates the UI to show the count.
         */
        function listenForOnlineUsers() {
            onValue(onlineUsersRef, (snapshot) => {
                const users = snapshot.val();
                let count = 0;
                if (users) {
                    count = Object.keys(users).length;
                }
                onlineUsersCountDisplay.textContent = count;
                onlineUsersCountDisplay.classList.remove('loading-text');
            }, (error) => {
                console.error("Error listening for online users:", error);
                onlineUsersCountDisplay.textContent = 'Error';
                onlineUsersCountDisplay.classList.remove('loading-text');
                onlineUsersCountDisplay.classList.add('error-message');
            });
        }

        async function isUserOnline(username) {
            const userKey = username.replace(/\s/g, '_');
            try {
                const snapshot = await get(ref(database, `online_users/${userKey}`));
                return snapshot.exists() && snapshot.val() === true;
            } catch (error) {
                console.error("Error checking online status:", error);
                return false;
            }
        }



        sendInviteBtn.addEventListener('click', async () => {
            if (!currentUsername) {
                showSendInviteMessage("Please generate your username first.", 'error');
                return;
            }

            const recipientUsername = inviteInput.value.trim();
            if (!recipientUsername) {
                showSendInviteMessage("Please enter a username to invite.", 'error');
                return;
            }

            if (recipientUsername === currentUsername) {
                showSendInviteMessage("You cannot invite yourself.", 'error');
                return;
            }

            // Prevent sending invite if user is in matchmaking
            if (currentRoomRef) {
                showSendInviteMessage("You are currently looking for a random game. Please cancel to send an invite.", 'error');
                return;
            }


            hideSendInviteMessage();

            const online = await isUserOnline(recipientUsername);
            if (!online) {
                showSendInviteMessage(`"${recipientUsername}" is not online or spelled incorrectly.`, 'error');
                return;
            }

            const newInvite = {
                sender: currentUsername,
                recipient: recipientUsername,
                status: 'pending',
                timestamp: Date.now()
            };

            try {
                const newInviteRef = push(invitesRef);
                const inviteId = newInviteRef.key;

                await set(newInviteRef, newInvite);
                showSendInviteMessage(`Invite sent to ${recipientUsername}!`, 'success');
                inviteInput.value = '';

                const inviteStatusRef = ref(database, `invites/${inviteId}/status`);
                inviteOnDisconnectRefs[inviteId] = onDisconnect(inviteStatusRef);
                await inviteOnDisconnectRefs[inviteId].set('cancelled')
                    .catch(err => console.error(`Failed to set onDisconnect for invite ${inviteId}:`, err));
                console.log(`onDisconnect set for invite ${inviteId}`);

            } catch (error) {
                console.error("Error sending invite:", error);
                showSendInviteMessage(`Failed to send invite: ${error.message}`, 'error');
            }
        });

        function renderInviteItem(inviteId, inviteData, listElement, isSenderView) {
            let listItem = document.getElementById(`invite-${inviteId}`);
            if (listItem) {
                listItem.remove();
            }

            listItem = document.createElement('li');
            listItem.id = `invite-${inviteId}`;
            listItem.classList.add('invite-item');

            let contentHTML = '';
            let actionsHTML = '';

            if (isSenderView) {
                contentHTML = `<span>To: <strong>${inviteData.recipient}</strong> - Status: <span class="invite-status-pending">${inviteData.status.toUpperCase()}</span></span>`;
                if (inviteData.status === 'pending') {
                    actionsHTML = `
                                    <div class="invite-actions">
                                        <button class="cancel-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">cancel</span></button>
                                    </div>
                                `;
                }
            } else { // Recipient view
                contentHTML = `<span>From: <strong>${inviteData.sender}</strong></span>`;
                if (inviteData.status === 'pending') {
                    actionsHTML = `
                                    <div class="invite-actions">
                                        <button class="accept-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">check</span></button>
                                        <button class="reject-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">close</span></button>
                                    </div>
                                `;
                } else {
                    contentHTML += ` - Status: ${inviteData.status.toUpperCase()}`;
                }
            }

            listItem.innerHTML = contentHTML + actionsHTML;
            listElement.appendChild(listItem);

            // Add event listeners for buttons
            if (isSenderView && inviteData.status === 'pending') {
                const cancelBtn = listItem.querySelector('.cancel-btn');
                if (cancelBtn) {
                    cancelBtn.onclick = () => handleInviteCancel(inviteId);
                }
            } else if (!isSenderView && inviteData.status === 'pending') {
                const acceptBtn = listItem.querySelector('.accept-btn');
                const rejectBtn = listItem.querySelector('.reject-btn');

                if (acceptBtn) {
                    acceptBtn.onclick = () => handleInviteResponse(inviteId, 'accepted');
                }
                if (rejectBtn) {
                    rejectBtn.onclick = () => handleInviteResponse(inviteId, 'rejected');
                }
            }
        }

        async function handleInviteResponse(inviteId, status) {
            try {
                const inviteRef = ref(database, `invites/${inviteId}`);
                await update(inviteRef, { status: status });
                console.log(`Invite ${inviteId} ${status}.`);
                // If accepted/rejected, cancel onDisconnect for this invite
                if (inviteOnDisconnectRefs[inviteId]) {
                    await inviteOnDisconnectRefs[inviteId].cancel();
                    delete inviteOnDisconnectRefs[inviteId];
                }
            } catch (error) {
                console.error(`Error ${status} invite ${inviteId}:`, error);
                showInviteMessage(`Failed to ${status} invite: ${error.message}`, 'error');
            }
        }

        async function handleInviteCancel(inviteId) {
            try {
                const inviteRef = ref(database, `invites/${inviteId}`);
                await update(inviteRef, { status: 'cancelled' });
                console.log(`Invite ${inviteId} cancelled by sender.`);
                // If cancelled by sender, cancel onDisconnect for this invite
                if (inviteOnDisconnectRefs[inviteId]) {
                    await inviteOnDisconnectRefs[inviteId].cancel();
                    delete inviteOnDisconnectRefs[inviteId];
                }
            } catch (error) {
                console.error(`Error canceling invite ${inviteId}:`, error);
                showSendInviteMessage(`Failed to cancel invite: ${error.message}`, 'error');
            }
        }

        function listenForInvites(username) {
            if (!username) return;

            sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
            receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';

            onValue(invitesRef, (snapshot) => {
                const invites = snapshot.val();

                const tempSentList = document.createElement('ul');
                const tempReceivedList = document.createElement('ul');

                if (invites) {
                    Object.entries(invites).forEach(([inviteId, inviteData]) => {
                        if (inviteData.sender === username) {
                            if (inviteData.status === 'pending' || inviteData.status === 'accepted') {
                                renderInviteItem(inviteId, inviteData, tempSentList, true);
                            }
                        } else if (inviteData.recipient === username) {
                            if (inviteData.status === 'pending') {
                                renderInviteItem(inviteId, inviteData, tempReceivedList, false);
                            }
                        }

                        // Clean up invites that are no longer relevant (e.g., cancelled, rejected)
                        if (inviteData.status === 'cancelled' || inviteData.status === 'rejected') {
                            const itemToRemove = document.getElementById(`invite-${inviteId}`);
                            if (itemToRemove) {
                                itemToRemove.remove();
                            }
                            // Also remove from database for cleanup
                            remove(ref(database, `invites/${inviteId}`))
                                .then(() => console.log(`Invite ${inviteId} (${inviteData.status}) removed from DB.`))
                                .catch(err => console.error(`Error removing ${inviteData.status} invite ${inviteId}:`, err));
                        }
                    });
                }

                sentInvitesList.innerHTML = '';
                if (tempSentList.children.length > 0) {
                    Array.from(tempSentList.children).forEach(child => sentInvitesList.appendChild(child));
                } else {
                    sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
                }

                receivedInvitesList.innerHTML = '';
                if (tempReceivedList.children.length > 0) {
                    Array.from(tempReceivedList.children).forEach(child => receivedInvitesList.appendChild(child));
                } else {
                    receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';
                }

            }, (error) => {
                console.error("Error listening for invites:", error);
                showGeneralError(`Error loading invites: ${error.message}`);
                sentInvitesList.innerHTML = `<li class="error-message">Error loading sent invites: ${error.message}</li>`;
                receivedInvitesList.innerHTML = `<li class="error-message">Error loading pending challenges: ${error.message}</li>`;
            });
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            generateOrLoadUsername();
            listenForOnlineUsers();
        });

        // NEW: Event listener for the matchmaking button
        if (findRandomGameBtn) {
            findRandomGameBtn.addEventListener('click', findAndJoinRoom);
        }

        // Dark mode toggle event listener
        if (darkModeToggle) {
            darkModeToggle.addEventListener('change', () => {
                if (darkModeToggle.checked) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
            });
        }

        // Copy username to clipboard
        copyBtn.addEventListener('click', async () => {
            const usernameToCopy = usernameDisplay.textContent;
            if (usernameToCopy && usernameToCopy !== 'Loading username...' && usernameToCopy !== 'ErrorUser' && usernameToCopy !== 'NoDataUser') {
                try {
                    await navigator.clipboard.writeText(usernameToCopy);
                    console.log('Username copied to clipboard:', usernameToCopy);
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<span class="material-symbols-outlined">check</span> Copied!';
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy username:', err);
                    showGeneralError('Failed to copy username. Please copy manually.');
                }
            } else {
                showGeneralError('No username to copy.');
            }
        });




        // game functions

        function showWinAnimation(winner) {
            const overlay = document.getElementById('winOverlay');
            overlay.style.display = 'block';
            overlay.innerHTML = ''; // clear previous

            const columns = Math.floor(window.innerWidth / 20);

            for (let i = 0; i < columns; i++) {
                const col = document.createElement('div');
                col.style.position = 'absolute';
                col.style.left = `${i * 20}px`;
                col.style.top = `-${Math.random() * 500}px`;
                col.style.fontFamily = 'monospace';
                col.style.color = 'black';
                col.style.fontSize = '2rem';
                col.textContent = Math.random() > 0.5 ? 'X' : 'O';
                overlay.appendChild(col);

                animateDrop(col);
            }

            setTimeout(() => {
                overlay.style.display = 'none';
            }, 5000); // hide after 5 seconds
        }

        function animateDrop(element) {
            let top = parseFloat(element.style.top);
            const interval = setInterval(() => {
                top += 5;
                if (top > window.innerHeight) {
                    top = -50; // reset to top
                    element.textContent = Math.random() > 0.5 ? 'X' : 'O';
                }
                element.style.top = `${top}px`;
            }, 30);
        }

        function renderNames() {
            name1Span.textContent = players[0];
            name2Span.textContent = players[1];
            if (currentPlayer === 0) {
                name1Span.classList.add('highlight');
                name2Span.classList.remove('highlight');
            } else {
                name2Span.classList.add('highlight');
                name1Span.classList.remove('highlight');
            }
        }

        function createBoard() {
            bigBoardDiv.innerHTML = '';
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    for (let sr = 0; sr < 3; sr++) {
                        for (let sc = 0; sc < 3; sc++) {
                            const subcell = document.createElement('div');
                            subcell.classList.add('subcell');
                            subcell.dataset.bigRow = r;
                            subcell.dataset.bigCol = c;
                            subcell.dataset.subRow = sr;
                            subcell.dataset.subCol = sc;
                            subcell.addEventListener('click', handleMove);
                            cell.appendChild(subcell);
                        }
                    }
                    bigBoardDiv.appendChild(cell);
                }
            }
        }



        async function handleMove(e) {


            if (currentUsername !== players[currentPlayer]) {
                console.log("It's not your turn!");
                return; // Exit the function, preventing the move
            }




            const el = e.currentTarget;
            const br = +el.dataset.bigRow, bc = +el.dataset.bigCol;
            const sr = +el.dataset.subRow, sc = +el.dataset.subCol;

            if (bigBoardState[br][bc] !== EMPTY) return; // already won/drawn
            if (subBoardStates[br][bc][sr][sc] !== EMPTY) return; // already filled
            if (nextSubgrid && (nextSubgrid[0] !== br || nextSubgrid[1] !== bc)) return; // wrong grid

            const mark = currentPlayer === 0 ? X : O;
            subBoardStates[br][bc][sr][sc] = mark;
            el.textContent = mark === X ? 'X' : 'O';

            // Check if subgrid is won
            if (checkWin(subBoardStates[br][bc], mark)) {
                bigBoardState[br][bc] = mark;
                const cell = findCell(br, bc);
                cell.classList.add('won');
                const overlay = document.createElement('div');
                overlay.classList.add('winner-mark');
                overlay.textContent = mark === X ? 'X' : 'O';
                cell.appendChild(overlay);

            } else if (isFullSubgrid(subBoardStates[br][bc])) {
                bigBoardState[br][bc] = DRAW;
                const cell = findCell(br, bc);
                cell.classList.add('won');
                const overlay = document.createElement('div');
                overlay.classList.add('winner-mark');
                overlay.textContent = '—';
                cell.appendChild(overlay);
            }

            // Check if big grid is won
            if (checkWin(bigBoardState, mark)) {
                winmessageDIV.style.display = 'block';
                showWinAnimation(players[currentPlayer]);
                winmessage.innerHTML = `${players[currentPlayer]} won!`;

                gameDiv.querySelectorAll('.subcell').forEach(sc => sc.style.pointerEvents = 'none');
                return;
            }

            if (isBoardFull(bigBoardState)) {
                winmessageDiv.style.display = 'block';
                showWinAnimation('draw');
                winmessage.innerHTML = `A bore draw!`;
                gameDiv.querySelectorAll('.subcell').forEach(sc => sc.style.pointerEvents = 'none');
                return;
            }

            // Determine next subgrid
            if (bigBoardState[sr][sc] === EMPTY) {
                nextSubgrid = [sr, sc];
            } else {
                nextSubgrid = null;
            }

            currentPlayer = 1 - currentPlayer;
            renderNames();
            highlightNextSubgrid();



            updateFirebaseState();

            // Update the Firebase Realtime Database
            //await update(ref( database, 'game_rooms/' + gameRoomName + '/state'), updatedState);

        }

        function isBoardFull(board) {
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    // If any cell is null, it's not full. 'X', 'O', or 'draw' means it's occupied.
                    if (board[r][c] === null) {
                        return false;
                    }
                }
            }
            return true;
        }

        function findCell(r, c) {
            return [...bigBoardDiv.children].find(el => +el.dataset.row === r && +el.dataset.col === c);
        }

        function highlightNextSubgrid() {
            [...bigBoardDiv.children].forEach(cell => {
                const r = +cell.dataset.row, c = +cell.dataset.col;
                cell.classList.remove('active-subgrid');
                if (bigBoardState[r][c] === EMPTY &&
                    (!nextSubgrid || (nextSubgrid[0] === r && nextSubgrid[1] === c))) {
                    cell.classList.add('active-subgrid');
                }

            });
        }

        function checkWin(board, mark) {
            for (let i = 0; i < 3; i++) {
                if (board[i][0] === mark && board[i][1] === mark && board[i][2] === mark) return true;
                if (board[0][i] === mark && board[1][i] === mark && board[2][i] === mark) return true;
            }
            if (board[0][0] === mark && board[1][1] === mark && board[2][2] === mark) return true;
            if (board[0][2] === mark && board[1][1] === mark && board[2][0] === mark) return true;
            return false;
        }


        function isFullSubgrid(subgrid) {
            return subgrid.every(row => row.every(cell => cell !== EMPTY));
        }




        async function createGameRoom(initialState, player1Username, player2Username) {


            if (!player1Username || !player2Username) {
                throw new Error("Both player usernames must be defined");
            }

            // Sort usernames alphabetically for consistent room names
            const playersSorted = [player1Username, player2Username].sort();
            const gameRoomName = `${playersSorted[0]}_vs_${playersSorted[1]}`;

            currentRoomName = gameRoomName;

            // Make sure gameRoomsRef is a proper Firebase reference
            const gameRef = child(gameRoomsRef, gameRoomName);

            // Check if the game room already exists
            const snapshot = await get(gameRef);

            if (snapshot.exists()) {
                console.log(`Game room already exists: ${gameRoomName}`);
                return gameRoomName;
            }

            // Save the initial game state
            await set(gameRef, {
                createdAt: Date.now(),
                state: JSON.parse(JSON.stringify(initialState)),
                players: {
                    player1: player1Username,
                    player2: player2Username
                }
            });

            console.log(`Created new game room: ${gameRoomName}`);
            return gameRoomName;
        }


        // Add a new function to listen for game state changes
        function listenForGameUpdates(gameRoomName) {
            // Get a reference to the specific game room's state
            const gameStateRef = ref(database, 'game_rooms/' + gameRoomName + '/state');

            // Attach a real-time listener to the game state
            onValue(gameStateRef, (snapshot) => {
                const gameState = snapshot.val();

                if (gameState) {
                    // Update local game state variables
                    bigBoardState = gameState.bigBoardState;
                    subBoardStates = gameState.subBoardStates;
                    currentPlayer = gameState.currentPlayer;
                    nextSubgrid = gameState.nextSubgrid;

                    // Call a function to update the HTML display based on the new state
                    updateGameUI(gameState);
                }
            });
        }


        // Add a new function to update the UI based on the game state
        function updateGameUI(gameState) {
            // Update player names and highlights
            name1Span.textContent = players[0];
            name2Span.textContent = players[1];
            if (gameState.currentPlayer === 0) {
                name1Span.classList.add('highlight');
                name2Span.classList.remove('highlight');
            } else {
                name2Span.classList.add('highlight');
                name1Span.classList.remove('highlight');
            }

            // Loop through all subcells and update their content and classes
            const allSubcells = document.querySelectorAll('.subcell');
            allSubcells.forEach(el => {
                const br = +el.dataset.bigRow;
                const bc = +el.dataset.bigCol;
                const sr = +el.dataset.subRow;
                const sc = +el.dataset.subCol;

                const mark = gameState.subBoardStates[br][bc][sr][sc];
                el.textContent = mark === X ? 'X' : (mark === O ? 'O' : '');

                // Disable subcells that have been played
                if (mark !== EMPTY) {
                    el.style.pointerEvents = 'none';
                } else {
                    el.style.pointerEvents = 'auto';
                }
            });

            // Update big board highlights and winner marks
            const allCells = document.querySelectorAll('.cell');
            allCells.forEach(cell => {
                const r = +cell.dataset.row;
                const c = +cell.dataset.col;

                // Update winner marks
                const winnerMark = cell.querySelector('.winner-mark');
                if (gameState.bigBoardState[r][c] !== EMPTY) {
                    cell.classList.add('won');
                    if (!winnerMark) {
                        const overlay = document.createElement('div');
                        overlay.classList.add('winner-mark');
                        overlay.textContent = gameState.bigBoardState[r][c] === X ? 'X' : (gameState.bigBoardState[r][c] === O ? 'O' : '—');
                        cell.appendChild(overlay);
                    }
                } else {
                    cell.classList.remove('won');
                    if (winnerMark) {
                        winnerMark.remove();
                    }
                }

                // Update active subgrid highlights
                cell.classList.remove('active-subgrid');
                if (gameState.bigBoardState[r][c] === EMPTY && (!gameState.nextSubgrid || (gameState.nextSubgrid[0] === r && gameState.nextSubgrid[1] === c))) {
                    cell.classList.add('active-subgrid');
                }
            });

            // Check for a win and display the win message
            if (checkWin(gameState.bigBoardState, X) || checkWin(gameState.bigBoardState, O)) {

                winmessageDIV.style.display = 'block';
                const winner = checkWin(gameState.bigBoardState, X) ? players[0] : players[1];
                winmessage.innerHTML = `${winner} won!`;
                showWinAnimation(winner);
                gameDiv.querySelectorAll('.subcell').forEach(sc => sc.style.pointerEvents = 'none');

                endGame(gameRoomName);

                

            } else {
                winmessageDIV.style.display = 'none';
            }

            // check for draw
            if (isBoardFull(bigBoardState)) {

                winmessageDIV.style.display = 'block';
                const winner = checkWin(gameState.bigBoardState, X) ? players[0] : players[1];
                winmessage.innerHTML = `${winner} won!`;
                showWinAnimation(winner);
                gameDiv.querySelectorAll('.subcell').forEach(sc => sc.style.pointerEvents = 'none');

                endGame(gameRoomName);

                return;
            }


        }

        function endGame(gameId) {

            const savedGameId = localStorage.getItem('ttt2_currentGameRoom');

            const gameRef = ref(database,'games/' + savedGameId);

            remove(gameRef)
                .then(() => {
                    console.log("Game successfully deleted!");
                })
                .catch((error) => {
                    console.error("Error removing game: ", error);
                });

            // Also clear local storage after the game is over
            localStorage.removeItem('ttt2_currentGameRoom');
        }


        // Add this new function to handle updating the database
        async function updateFirebaseState() {

            if (!currentRoomName) {
                console.error("No active game room to update.");
                return;
            }

            const gameStateRef = ref(database, 'game_rooms/' + currentRoomName + '/state');
            const newState = {
                bigBoardState: bigBoardState,
                subBoardStates: subBoardStates,
                currentPlayer: currentPlayer,
                nextSubgrid: nextSubgrid
            };

            try {
                await set(gameStateRef, newState);
                console.log("Game state updated in Firebase.");
            } catch (error) {
                console.error("Error updating game state:", error);
            }
        }




    </script>
</body>
</html>
