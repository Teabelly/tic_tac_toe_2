<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <title>Random Username Generator</title>
    
    
 
 	 <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=closecontent_copyinfosend" />
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
    
        /* Your existing CSS here, adapted for the username generator context */
        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: auto;
        }

        body {
            font-family: "Inter", sans-serif; /* Prefer Inter as per instructions */
            
            background-image: url('background_v001p0.png');
    			background-size: cover;
            
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #f0f4f8; /* Light background */
            color: #333;
            padding: 1rem;
            box-sizing: border-box;
        }

        .container {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); /* Added subtle shadow */
            text-align: center;
            max-width: 90%;
            width: 400px;
            margin-bottom: 2%;
        }

        /* New styles for the username row */
        .username-info-row {
            display: flex;
            align-items: center; /* Vertically align items in the middle */
            justify-content: center; /* Center content horizontally */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 0.5rem; /* Space between items */
            margin-bottom: 1.5rem; /* Keep some space below this row */
        }

        .username-info-row h1 {
            font-size: 1.5rem; /* Adjust font size to fit in a row */
            margin-bottom: 0; /* Remove default h1 margin */
            white-space: nowrap; /* Prevent "Username:" from wrapping */
            color: #1a202c; /* Ensure color is consistent */
        }

        #usernameDisplay {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0; /* Remove default margin for inline element */
            flex-grow: 1; /* Allow it to take available space */
            text-align: left; /* Align text to left within its flex item */
            min-height: 0.5rem; /* Ensure space even when loading */
            display: flex; /* Use flex to center content vertically within its own space */
            align-items: center;
            justify-content: flex-start; /* Align text to start */
            word-break: break-all; /* Prevent overflow for long names */
        }

        .loading-text {
            color: #6b7280;
            font-style: italic;
        }



        /* New styles for copy button */
        .copy-button {
            background-color: #69baceff; /* A lighter blue */
            color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer; /* Indicate it's clickable */
            border: none;
            outline: none;
            
            display: flex; /* To center the icon */
            align-items: center;
            justify-content: center;
        }
        .copy-button:hover {
            background-color: #60a5fa;
            transform: translateY(-1px);
        }
        .copy-button:active {
            background-color: #69baceff;
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba[0, 0, 0, 0.1];
        }
        .copy-button .material-symbols-outlined {
            font-size: 1.2rem; /* Adjust icon size */
            line-height: 1; /* Ensure icon is centered */
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; /* Ensure icon style */
        }
         
        .info-username {
            background-color: #60a5fa; /* A lighter blue */
            color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            
            border: none;
            outline: none;
            
            display: flex; /* To center the icon */
            align-items: center;
            justify-content: center;
        }

        .error-message {
            color: #e53e3e; /* Red for errors */
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .success-message {
            color: #38a169; /* Green for success */
            margin-top: 1rem;
            font-size: 0.9rem;
        }


        /* Dark Mode styles (from original script, adapted) */
        body.dark-mode {
            background-color: #111;
            color: #999;
        }
        body.dark-mode .container {
            background-color: #222;
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.05);
        }
        body.dark-mode h1 {
            color: #eee;
        }
        body.dark-mode #usernameDisplay, body.dark-mode #onlineUsersCount, body.dark-mode .invite-item, body.dark-mode #matchStatus {
            color: #ccc;
        }
        body.dark-mode .generate-button {
            background-color: #3182ce;
        }
        body.dark-mode .generate-button:hover {
            background-color: #2b6cb0;
        }
        body.dark-mode .generate-button:active {
            background-color: #1a569d;
        }
        body.dark-mode .copy-button {
            background-color: #3b82f6;
        }
        body.dark-mode .copy-button:hover {
            background-color: #2563eb;
        }
        body.dark-mode .copy-button:active {
            background-color: #1a569d;
        }
        body.dark-mode .loading-text {
            color: #888;
        }
        body.dark-mode .error-message {
            color: #f56565;
        }
        body.dark-mode .success-message {
            color: #68d391;
        }

        /* Dark mode toggle switch styles (from original script) */
        .switch {
            position: absolute; /* Changed to absolute to position independently */
            top: 1rem; /* Adjust as needed */
            right: 1rem; /* Adjust as needed */
            display: inline-block;
            width: 50px;
            height: 24px;
            z-index: 10; /* Ensure it's above other content */
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "☀";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            color: black;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
            content: "☾";
            color: black;
        }
         
        /* Material Symbols Icon settings */
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24
        }
         
        /* Styles for online users count */
        #onlineUsersCount {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4a5568;
            margin-top: 0.5rem; /* Adjust spacing as needed */
        }

        /* Styles for invite section */
        #inviteInput {
            border: 1px solid #cbd5e0; /* Light gray border */
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: calc(100% - 70px); /* Adjust width to fit button */
            margin-right: 0.5rem;
            box-sizing: border-box; /* Include padding in width */
            font-size: 1rem;
            color: #333;
        }
        body.dark-mode #inviteInput {
            background-color: #444;
            border-color: #555;
            color: #eee;
        }

        #sendInviteBtn {
            background-color: #3db15eff; /* Green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #sendInviteBtn:hover {
            background-color: #45a049;
        }
        body.dark-mode #sendInviteBtn {
            background-color: #48bb78;
        }
        body.dark-mode #sendInviteBtn:hover {
            background-color: #38a169;
        }

        /* Styles for invite lists */
        .invite-list {
            list-style: none;
            padding: 0;
            margin-top: 1rem;
            text-align: left;
        }

        .invite-item {
            background-color: #f0f4f8; /* Light background for items */
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            font-size: 1rem;
            color: #333;
            word-break: break-word; /* Ensure long usernames wrap */
        }
        body.dark-mode .invite-item {
            background-color: #333;
            color: #ccc;
            box-shadow: 0 1px 3px rgba(255, 255, 255, 0.05);
        }

        .invite-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.3rem;
            margin-left: 0.5rem;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }
        .invite-actions button:hover {
            transform: scale(1.1);
        }
        .invite-actions .accept-btn {
            color: #4CAF50; /* Green tick */
        }
        .invite-actions .reject-btn {
            color: #e53e3e; /* Red cross */
        }
        .invite-actions .cancel-btn { /* NEW STYLE for cancel button */
            color: #ff9800; /* Orange for cancel */
        }
        
        .invite-status-pending {
            color: #6b7280; /* Gray for pending */
            font-style: italic;
            font-size: 0.9em;
        }

        /* Styles for random match section */
        #randomMatchSection {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e2e8f0; /* Separator line */
        }
        body.dark-mode #randomMatchSection {
            border-color: #4a5568;
        }

        #findRandomGameBtn {
            background-color: #b46463ff; /* Purple */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        #findRandomGameBtn:hover {
            background-color: #b46462ff;
            transform: translateY(-1px);
        }
        #findRandomGameBtn:active {
            background-color: #7D3C98;
            transform: translateY(0);
        }
        #matchStatus {
            margin-top: 1rem;
            font-size: 1.1rem;
            font-weight: 500;
        }
        .match-loading {
            color: #60a5fa; /* Blue for loading */
            font-style: italic;
        }
        .match-found {
            color: #38a169; /* Green for found */
            font-weight: bold;
        }
        .match-error {
            color: #e53e3e; /* Red for error */
        }

    </style>
    
</head>

<body>


		// red b46463ff
		// blue 69baceff
		// green 3db15eff
		// yellow e5de31ff

    <label class="switch" id="darkModeSwitch">
        <input type="checkbox" id="darkModeToggle">
        <span class="slider"></span>
    </label>


	 <div class="container" style="margin-top: 17%">

		<h1> Play Online </h1>
	 
	 </div>



    <div class="container" >
    		
    	  
        <div class="username-info-row">
            <h1>Username: </h1>

            <button id="copyBtn" class="copy-button">
            <span class="material-symbols-outlined">content_copy</span>
            </button>          
         
            <span id="usernameDisplay" class="loading-text">Loading...</span>
            <div id="info-username"><span class="material-symbols-outlined"> info </span></div>
         
         
        </div>
        <p id="errorMessage" class="error-message hidden"></p>
        <p id="inviteMessage" class="hidden"></p>
    </div>
    
    <div class="container" >
        <h1>Send Invite: </h1>
        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
            <input type="text" id="inviteInput" placeholder="username..."></input>
            <button id="sendInviteBtn"><span class="material-symbols-outlined">send</span></button>
        </div>
        <p id="sendInviteMessage" class="hidden"></p> <ul id="sentInvitesList" class="invite-list">
            <li class="loading-text">No sent invites.</li>
        </ul>
    </div>
    
    <div class="container" style="border-color: #3db15eff; border-width: 5px; border-style: solid;">
        <h1>Challenge(s): </h1>
        <ul id="receivedInvitesList" class="invite-list">
            <li class="loading-text">No pending challenges.</li>
        </ul>
    </div>

    <div class="container" style="border-color: #e5de31ff; border-width: 5px; border-style: solid;">
        <h1>Users Online:</h1>
        <span id="onlineUsersCount" class="loading-text">Counting...</span>
    </div>

    <div class="container" id="randomMatchSection" style="border-color: #69baceff; border-width: 5px; border-style: solid;">
        <h1>Find Random Game:</h1>
        <button id="findRandomGameBtn">Find Opponent</button>
        <p id="matchStatus" class="hidden"></p>
    </div>

    
 
    
    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
        import { getDatabase, ref, get, set, onValue, push, update, remove, onDisconnect, query, limitToFirst, orderByChild } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-database.js";

        // Your Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD-wIuod1HspD7ffLzqsJGlsBMoi1iujZ8",
            authDomain: "tic-tac-toe-2-44691.firebaseapp.com",
            projectId: "tic-tac-toe-2-44691",
            storageBucket: "tic-tac-toe-2-44691.firebasestorage.app",
            messagingSenderId: "947987116391",
            appId: "1:947987116391:web:c2c64bc30fd0f810627fc2",
            measurementId: "G-WDR5ZXGXQ7",
            databaseURL: "https://tic-tac-toe-2-44691-default-rtdb.europe-west1.firebasedatabase.app"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Firebase References
        const usernameComponentsRef = ref(database, 'username_components');
        const onlineUsersRef = ref(database, 'online_users');
        const invitesRef = ref(database, 'invites'); 
        const waitingRoomsRef = ref(database, 'waiting_rooms'); // NEW Firebase Ref

        // DOM Elements
        const usernameDisplay = document.getElementById('usernameDisplay');
        const generateBtn = document.getElementById('generateBtn');
        const errorMessage = document.getElementById('errorMessage'); 
        const inviteMessage = document.getElementById('inviteMessage'); 
        const sendInviteMessage = document.getElementById('sendInviteMessage'); 
        const darkModeToggle = document.getElementById('darkModeToggle');
        const onlineUsersCountDisplay = document.getElementById('onlineUsersCount');
        const copyBtn = document.getElementById('copyBtn');

        const inviteInput = document.getElementById('inviteInput');
        const sendInviteBtn = document.getElementById('sendInviteBtn');
        const sentInvitesList = document.getElementById('sentInvitesList');
        const receivedInvitesList = document.getElementById('receivedInvitesList');

        // NEW DOM elements for matchmaking
        const findRandomGameBtn = document.getElementById('findRandomGameBtn');
        const matchStatusDisplay = document.getElementById('matchStatus');

        let currentUsername = null; 
        const localStorageKey = 'userGeneratedUsername'; 

        const inviteOnDisconnectRefs = {}; 
        let currentRoomRef = null; // NEW: To keep track of the room the current user is in

        // --- Helper Functions for UI Messages ---
        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
            element.classList.remove('error-message', 'success-message', 'match-loading', 'match-found', 'match-error');
        }

        function showMessage(element, message, type = 'error') {
            element.textContent = message;
            element.classList.remove('hidden');
            element.classList.add(
                type === 'success' ? 'success-message' :
                type === 'loading' ? 'match-loading' :
                type === 'found' ? 'match-found' :
                'error-message'
            );
            // Hide after a few seconds, unless it's a 'loading' or 'found' message
            if (type !== 'loading' && type !== 'found') {
                setTimeout(() => hideMessage(element), 5000);
            }
        }

        function hideGeneralError() { hideMessage(errorMessage); }
        function showGeneralError(message) { showMessage(errorMessage, message, 'error'); }

        function hideInviteMessage() { hideMessage(inviteMessage); }
        function showInviteMessage(message, type = 'error') { showMessage(inviteMessage, message, type); }

        function hideSendInviteMessage() { hideMessage(sendInviteMessage); }
        function showSendInviteMessage(message, type = 'error') { showMessage(sendInviteMessage, message, type); }

        function hideMatchStatus() { hideMessage(matchStatusDisplay); }
        function showMatchStatus(message, type = 'error') { showMessage(matchStatusDisplay, message, type); }


        /**
         * Adds the current username to the online_users list in Firebase.
         * Sets up onDisconnect to remove the user from online_users.
         * @param {string} username - The username to set as online.
         * @param {string|null} oldUsername - The username that was previously online (if any).
         */
        async function setOnlineStatus(username, oldUsername = null) {
            if (!username) return;

            // Remove old username's online status if it exists and is different
            if (oldUsername && oldUsername !== username) {
                const oldUserRef = ref(database, `online_users/${oldUsername.replace(/\s/g, '_')}`);
                await set(oldUserRef, null).catch(error => console.error("Error removing old username's online status:", error));
                console.log(`User ${oldUsername} is now offline.`);
            }

            const userRef = ref(database, `online_users/${username.replace(/\s/g, '_')}`); 
            try {
                await set(userRef, true);
                // Set up onDisconnect to remove this user from online_users
                onDisconnect(userRef).remove();
                console.log(`User ${username} is now online.`);
            } catch (error) {
                console.error("Error setting online status:", error);
                showGeneralError(`Failed to set online status: ${error.message}`);
            }
        }

        /**
         * Generates a random username by fetching components from Firebase.
         * @param {boolean} forceNew - If true, generates a new username even if one is stored.
         */
        async function generateOrLoadUsername(forceNew = false) {
            usernameDisplay.textContent = 'Loading username...';
            usernameDisplay.classList.add('loading-text');
            hideGeneralError();
            hideInviteMessage();
            hideSendInviteMessage();
            hideMatchStatus(); // Clear match status on username change

            let usernameFromLocalStorage = localStorage.getItem(localStorageKey);
            let newUsername = null;

            // Handle existing username cleanup for the *old* currentUsername, if any
            // This is crucial when generating a *new* one to avoid lingering online status.
            if (currentUsername) {
                // Cancel all onDisconnect operations for invites previously sent by this user
                for (const inviteId in inviteOnDisconnectRefs) {
                    if (inviteOnDisconnectRefs.hasOwnProperty(inviteId)) {
                        await inviteOnDisconnectRefs[inviteId].cancel()
                            .catch(err => console.error(`Error canceling onDisconnect for invite ${inviteId}:`, err));
                    }
                }
                inviteOnDisconnectRefs = {}; // Clear the map

                // Stop listening for all invites (the onValue listener)
                off(invitesRef); 
                // Clear existing invites from UI for old user
                sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
                receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';

                // If user was in a waiting room, remove them from it
                if (currentRoomRef) {
                    console.log("Leaving previous room on username change.");
                    await remove(currentRoomRef).catch(err => console.error("Error leaving previous room:", err));
                    currentRoomRef = null;
                }
            }


            if (!forceNew && usernameFromLocalStorage) {
                newUsername = usernameFromLocalStorage;
                usernameDisplay.textContent = newUsername;
                usernameDisplay.classList.remove('loading-text');
                console.log("Loaded username from localStorage:", newUsername);
            } else {
                try {
                    const snapshot = await get(usernameComponentsRef);

                    if (snapshot.exists()) {
                        const components = snapshot.val();

                        const emotions = components.emotions ? Object.keys(components.emotions) : [];
                        const colors = components.colours ? Object.keys(components.colours) : [];
                        const animals = components.animal ? Object.keys(components.animal) : [];

                        if (emotions.length > 0 && colors.length > 0 && animals.length > 0) {
                            const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                            const randomColor = colors[Math.floor(Math.random() * colors.length)];
                            const randomAnimal = animals[Math.floor(Math.random() * animals.length)];

                            newUsername = `${randomEmotion} ${randomColor} ${randomAnimal}`;
                            usernameDisplay.textContent = newUsername;
                            usernameDisplay.classList.remove('loading-text');
                            localStorage.setItem(localStorageKey, newUsername); // Save to localStorage
                            console.log("Generated and saved new username:", newUsername);

                        } else {
                            showGeneralError("Username components are incomplete or empty in Firebase. Please check your database structure.");
                            newUsername = "FallbackUser"; 
                            usernameDisplay.textContent = newUsername;
                            usernameDisplay.classList.remove('loading-text');
                            localStorage.setItem(localStorageKey, newUsername); // Save fallback
                        }
                    } else {
                        showGeneralError("No username components found in Firebase. Please ensure 'username_components' exists and contains data.");
                        newUsername = "NoDataUser";
                        usernameDisplay.textContent = newUsername;
                        usernameDisplay.classList.remove('loading-text');
                        localStorage.setItem(localStorageKey, newUsername); // Save fallback
                    }
                } catch (error) {
                    console.error("Error fetching username components from Firebase:", error);
                    showGeneralError(`Failed to fetch username components: ${error.message}`);
                    newUsername = "ErrorUser";
                    usernameDisplay.textContent = newUsername;
                    usernameDisplay.classList.remove('loading-text');
                    localStorage.setItem(localStorageKey, newUsername); // Save error fallback
                }
            }
            
            // Set online status and start listeners for the new or loaded username
            if (newUsername) {
                // Pass oldUsername to setOnlineStatus for explicit removal
                setOnlineStatus(newUsername, currentUsername); 
                currentUsername = newUsername; // Update global currentUsername
                listenForInvites(currentUsername); 
            }
        }

        /**
         * Listens for changes in the online_users node and updates the UI to show the count.
         */
        function listenForOnlineUsers() {
            onValue(onlineUsersRef, (snapshot) => {
                const users = snapshot.val();
                let count = 0;
                if (users) {
                    count = Object.keys(users).length;
                }
                onlineUsersCountDisplay.textContent = count;
                onlineUsersCountDisplay.classList.remove('loading-text');
            }, (error) => {
                console.error("Error listening for online users:", error);
                onlineUsersCountDisplay.textContent = 'Error';
                onlineUsersCountDisplay.classList.remove('loading-text');
                onlineUsersCountDisplay.classList.add('error-message');
            });
        }

        /**
         * Checks if a username exists in the online_users list.
         * @param {string} username - The username to check.
         * @returns {Promise<boolean>} True if online, false otherwise.
         */
        async function isUserOnline(username) {
            const userKey = username.replace(/\s/g, '_');
            try {
                const snapshot = await get(ref(database, `online_users/${userKey}`));
                return snapshot.exists() && snapshot.val() === true;
            } catch (error) {
                console.error("Error checking online status:", error);
                return false;
            }
        }

        /**
         * Sends an invite to another user.
         */
        sendInviteBtn.addEventListener('click', async () => {
            if (!currentUsername) {
                showSendInviteMessage("Please generate your username first.", 'error');
                return;
            }

            const recipientUsername = inviteInput.value.trim();
            if (!recipientUsername) {
                showSendInviteMessage("Please enter a username to invite.", 'error');
                return;
            }

            if (recipientUsername === currentUsername) {
                showSendInviteMessage("You cannot invite yourself.", 'error');
                return;
            }
            
            // Prevent sending invite if user is in matchmaking
            if (currentRoomRef) {
                showSendInviteMessage("You are currently looking for a random game. Please cancel to send an invite.", 'error');
                return;
            }


            hideSendInviteMessage();

            const online = await isUserOnline(recipientUsername);
            if (!online) {
                showSendInviteMessage(`"${recipientUsername}" is not online or spelled incorrectly.`, 'error');
                return;
            }

            const newInvite = {
                sender: currentUsername,
                recipient: recipientUsername,
                status: 'pending',
                timestamp: Date.now()
            };

            try {
                const newInviteRef = push(invitesRef);
                const inviteId = newInviteRef.key;

                await set(newInviteRef, newInvite);
                showSendInviteMessage(`Invite sent to ${recipientUsername}!`, 'success');
                inviteInput.value = '';

                const inviteStatusRef = ref(database, `invites/${inviteId}/status`);
                inviteOnDisconnectRefs[inviteId] = onDisconnect(inviteStatusRef);
                await inviteOnDisconnectRefs[inviteId].set('cancelled')
                    .catch(err => console.error(`Failed to set onDisconnect for invite ${inviteId}:`, err));
                console.log(`onDisconnect set for invite ${inviteId}`);

            } catch (error) {
                console.error("Error sending invite:", error);
                showSendInviteMessage(`Failed to send invite: ${error.message}`, 'error');
            }
        });


        /**
         * Displays a single invite item in the UI.
         * @param {string} inviteId - The unique ID of the invite.
         * @param {object} inviteData - The invite object from Firebase.
         * @param {HTMLElement} listElement - The UL element to append to (sent or received list).
         * @param {boolean} isSenderView - True if rendering for the sender, false for recipient.
         */
        function renderInviteItem(inviteId, inviteData, listElement, isSenderView) {
            let listItem = document.getElementById(`invite-${inviteId}`);
            if (listItem) {
                listItem.remove();
            }

            listItem = document.createElement('li');
            listItem.id = `invite-${inviteId}`;
            listItem.classList.add('invite-item');

            let contentHTML = '';
            let actionsHTML = '';

            if (isSenderView) {
                contentHTML = `<span>To: <strong>${inviteData.recipient}</strong> - Status: <span class="invite-status-pending">${inviteData.status.toUpperCase()}</span></span>`;
                if (inviteData.status === 'pending') {
                    actionsHTML = `
                        <div class="invite-actions">
                            <button class="cancel-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">cancel</span></button>
                        </div>
                    `;
                }
            } else { // Recipient view
                contentHTML = `<span>From: <strong>${inviteData.sender}</strong></span>`;
                if (inviteData.status === 'pending') {
                    actionsHTML = `
                        <div class="invite-actions">
                            <button class="accept-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">check</span></button>
                            <button class="reject-btn" data-invite-id="${inviteId}"><span class="material-symbols-outlined">close</span></button>
                        </div>
                    `;
                } else {
                    contentHTML += ` - Status: ${inviteData.status.toUpperCase()}`;
                }
            }

            listItem.innerHTML = contentHTML + actionsHTML;
            listElement.appendChild(listItem);

            // Add event listeners for buttons
            if (isSenderView && inviteData.status === 'pending') {
                const cancelBtn = listItem.querySelector('.cancel-btn');
                if (cancelBtn) {
                    cancelBtn.onclick = () => handleInviteCancel(inviteId);
                }
            } else if (!isSenderView && inviteData.status === 'pending') {
                const acceptBtn = listItem.querySelector('.accept-btn');
                const rejectBtn = listItem.querySelector('.reject-btn');

                if (acceptBtn) {
                    acceptBtn.onclick = () => handleInviteResponse(inviteId, 'accepted');
                }
                if (rejectBtn) {
                    rejectBtn.onclick = () => handleInviteResponse(inviteId, 'rejected');
                }
            }
        }

        /**
         * Handles acceptance or rejection of an invite.
         * @param {string} inviteId - The ID of the invite.
         * @param {string} status - 'accepted' or 'rejected'.
         */
        async function handleInviteResponse(inviteId, status) {
            try {
                const inviteRef = ref(database, `invites/${inviteId}`);
                await update(inviteRef, { status: status });
                console.log(`Invite ${inviteId} ${status}.`);
                // If accepted/rejected, cancel onDisconnect for this invite
                if (inviteOnDisconnectRefs[inviteId]) {
                    await inviteOnDisconnectRefs[inviteId].cancel();
                    delete inviteOnDisconnectRefs[inviteId];
                }
            } catch (error) {
                console.error(`Error ${status} invite ${inviteId}:`, error);
                showInviteMessage(`Failed to ${status} invite: ${error.message}`, 'error');
            }
        }

        /**
         * Handles cancellation of an invite by the sender.
         * @param {string} inviteId - The ID of the invite to cancel.
         */
        async function handleInviteCancel(inviteId) {
            try {
                const inviteRef = ref(database, `invites/${inviteId}`);
                await update(inviteRef, { status: 'cancelled' });
                console.log(`Invite ${inviteId} cancelled by sender.`);
                // If cancelled by sender, cancel onDisconnect for this invite
                if (inviteOnDisconnectRefs[inviteId]) {
                    await inviteOnDisconnectRefs[inviteId].cancel();
                    delete inviteOnDisconnectRefs[inviteId];
                }
            } catch (error) {
                console.error(`Error canceling invite ${inviteId}:`, error);
                showSendInviteMessage(`Failed to cancel invite: ${error.message}`, 'error');
            }
        }


        /**
         * Listens for incoming and outgoing invites relevant to the current user.
         * @param {string} username - The current user's generated username.
         */
        function listenForInvites(username) {
            if (!username) return;

            sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
            receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';

            onValue(invitesRef, (snapshot) => {
                const invites = snapshot.val();
                
                const tempSentList = document.createElement('ul');
                const tempReceivedList = document.createElement('ul');

                if (invites) {
                    Object.entries(invites).forEach(([inviteId, inviteData]) => {
                        if (inviteData.sender === username) {
                            if (inviteData.status === 'pending' || inviteData.status === 'accepted') {
                                renderInviteItem(inviteId, inviteData, tempSentList, true);
                            }
                        } else if (inviteData.recipient === username) {
                            if (inviteData.status === 'pending') {
                                renderInviteItem(inviteId, inviteData, tempReceivedList, false);
                            }
                        }
                        
                        // Clean up invites that are no longer relevant (e.g., cancelled, rejected)
                        if (inviteData.status === 'cancelled' || inviteData.status === 'rejected') {
                            const itemToRemove = document.getElementById(`invite-${inviteId}`);
                            if (itemToRemove) {
                                itemToRemove.remove();
                            }
                            // Also remove from database for cleanup
                            remove(ref(database, `invites/${inviteId}`))
                                .then(() => console.log(`Invite ${inviteId} (${inviteData.status}) removed from DB.`))
                                .catch(err => console.error(`Error removing ${inviteData.status} invite ${inviteId}:`, err));
                        }
                    });
                }

                sentInvitesList.innerHTML = '';
                if (tempSentList.children.length > 0) {
                    Array.from(tempSentList.children).forEach(child => sentInvitesList.appendChild(child));
                } else {
                    sentInvitesList.innerHTML = '<li class="loading-text">No sent invites.</li>';
                }

                receivedInvitesList.innerHTML = '';
                if (tempReceivedList.children.length > 0) {
                    Array.from(tempReceivedList.children).forEach(child => receivedInvitesList.appendChild(child));
                } else {
                    receivedInvitesList.innerHTML = '<li class="loading-text">No pending challenges.</li>';
                }

            }, (error) => {
                console.error("Error listening for invites:", error);
                showGeneralError(`Error loading invites: ${error.message}`);
                sentInvitesList.innerHTML = `<li class="error-message">Error loading sent invites: ${error.message}</li>`;
                receivedInvitesList.innerHTML = `<li class="error-message">Error loading pending challenges: ${error.message}</li>`;
            });
        }


        // --- NEW: Matchmaking Logic ---

        findRandomGameBtn.addEventListener('click', async () => {
            if (!currentUsername) {
                showMatchStatus("Please generate your username first.", 'error');
                return;
            }
            if (currentRoomRef) {
                // If already in a room, allow user to cancel search (optional: add a "Cancel Search" button)
                showMatchStatus("Already looking for an opponent. Click again to restart search or wait.", 'loading');
                return;
            }

            findRandomGameBtn.disabled = true; // Prevent multiple clicks
            showMatchStatus("Looking for opponent...", 'loading');

            try {
                // 1. Try to find an existing 'waiting' room
                // Order by timestamp to potentially pick older rooms first (fairer)
                const waitingRoomsQuery = query(waitingRoomsRef, orderByChild('timestamp'), limitToFirst(1));
                const snapshot = await get(waitingRoomsQuery);

                let roomFound = false;
                let roomIdToJoin = null;
                let roomDataToJoin = null;

                if (snapshot.exists()) {
                    snapshot.forEach(childSnapshot => {
                        const room = childSnapshot.val();
                        // Only consider rooms with status 'waiting' and not already containing this player
                        if (room.status === 'waiting' && !room.players[currentUsername.replace(/\s/g, '_')]) {
                            // Check if room is not full (e.g., has less than 2 players)
                            if (Object.keys(room.players || {}).length < 2) {
                                roomIdToJoin = childSnapshot.key;
                                roomDataToJoin = room;
                                roomFound = true;
                            }
                        }
                    });
                }

                if (roomFound) {
                    // 2. Join the existing room
                    const playerKey = currentUsername.replace(/\s/g, '_');
                    currentRoomRef = ref(database, `waiting_rooms/${roomIdToJoin}`);
                    
                    const updates = {};
                    updates[`players/${playerKey}`] = true;
                    updates['timestamp'] = Date.now(); // Update timestamp to keep it fresh
                    
                    await update(currentRoomRef, updates);
                    console.log(`Joined existing room: ${roomIdToJoin}`);

                } else {
                    // 3. No waiting room, create a new one
                    const newRoomRef = push(waitingRoomsRef);
                    const newRoomId = newRoomRef.key;
                    const playerKey = currentUsername.replace(/\s/g, '_');
                    
                    const newRoom = {
                        status: 'waiting',
                        players: {
                            [playerKey]: true
                        },
                        timestamp: Date.now(),
                        player1: currentUsername, // Temporarily set player1 for easier lookup later
                        player2: null // Placeholder
                    };
                    await set(newRoomRef, newRoom);
                    currentRoomRef = newRoomRef;
                    console.log(`Created new room: ${newRoomId}`);
                }

                // Set onDisconnect to remove player from room if they leave/refresh
                if (currentRoomRef) {
                    const playerKey = currentUsername.replace(/\s/g, '_');
                    const playerInRoomRef = ref(database, `${currentRoomRef.toString().split(database.app.options.databaseURL + '/')[1]}/players/${playerKey}`);
                    
                    // Remove player from room on disconnect
                    onDisconnect(playerInRoomRef).remove();
                    
                    // Also set up a listener for this specific room to detect matches
                    onValue(currentRoomRef, async (snapshot) => {
                        const roomState = snapshot.val();
                        if (roomState) {
                            const playersInRoom = Object.keys(roomState.players || {});
                            if (roomState.status === 'waiting' && playersInRoom.length === 2) {
                                // Match found!
                                const opponent = playersInRoom.find(p => p !== currentUsername.replace(/\s/g, '_'));
                                if (opponent) {
                                    showMatchStatus(`Matched with: ${opponent.replace(/_/g, ' ')}!`, 'found');
                                    findRandomGameBtn.disabled = false; // Re-enable button
                                    
                                    // Update room status and player names for both
                                    const updates = {
                                        status: 'matched',
                                        player1: currentUsername,
                                        player2: opponent.replace(/_/g, ' ')
                                    };
                                    await update(currentRoomRef, updates);

                                    // Crucially, remove the room from waiting_rooms
                                    // This prevents others from trying to join and cleans up
                                    await remove(currentRoomRef);
                                    currentRoomRef = null; // Clear local reference

                                    // Detach listener for this specific room
                                    off(currentRoomRef); 
                                    console.log(`Match completed and room removed. Opponent: ${opponent.replace(/_/g, ' ')}`);
                                }
                            } else if (roomState.status === 'matched') {
                                // If we got here, it means the other player initiated the match removal
                                // The room might have been removed already, so this is a graceful exit.
                                if (roomState.player1 && roomState.player2) {
                                    const opponent = roomState.player1 === currentUsername ? roomState.player2 : roomState.player1;
                                    showMatchStatus(`Matched with: ${opponent}!`, 'found');
                                } else {
                                     showMatchStatus("Match found! Game starting...", 'found');
                                }
                                findRandomGameBtn.disabled = false;
                                currentRoomRef = null;
                                off(currentRoomRef); // Detach listener
                            }
                        } else {
                            // Room no longer exists (e.g., matched and removed by other player, or cleanup)
                            if (currentRoomRef) { // Only if we were previously in a room
                                showMatchStatus("Your matchmaking search was cancelled or an opponent disconnected.", 'error');
                                findRandomGameBtn.disabled = false;
                                currentRoomRef = null; // Reset
                                off(currentRoomRef); // Detach listener
                            }
                        }
                    });

                } else {
                    showMatchStatus("Could not find or create a room. Please try again.", 'error');
                    findRandomGameBtn.disabled = false;
                }

            } catch (error) {
                console.error("Error finding or joining room:", error);
                showMatchStatus(`Error: ${error.message}`, 'error');
                findRandomGameBtn.disabled = false;
                // Clean up if an error occurred during room setup
                if (currentRoomRef) {
                     await remove(currentRoomRef).catch(err => console.error("Error cleaning up room on error:", err));
                     currentRoomRef = null;
                }
            }
        });

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            generateOrLoadUsername(); 
            listenForOnlineUsers();
        });

        generateBtn.addEventListener('click', () => {
            generateOrLoadUsername(true); 
        }); 

        // Dark mode toggle event listener
        if (darkModeToggle) {
            darkModeToggle.addEventListener('change', () => {
                if (darkModeToggle.checked) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
            });
        }

        // Copy username to clipboard
        copyBtn.addEventListener('click', async () => {
            const usernameToCopy = usernameDisplay.textContent;
            if (usernameToCopy && usernameToCopy !== 'Loading username...' && usernameToCopy !== 'ErrorUser' && usernameToCopy !== 'NoDataUser') {
                try {
                    await navigator.clipboard.writeText(usernameToCopy);
                    console.log('Username copied to clipboard:', usernameToCopy);
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<span class="material-symbols-outlined">check</span> Copied!';
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy username:', err);
                    showGeneralError('Failed to copy username. Please copy manually.');
                }
            } else {
                showGeneralError('No username to copy.');
            }
        });
    </script>
</body>
</html>